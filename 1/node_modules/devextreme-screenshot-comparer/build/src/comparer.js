"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScreenshotsComparer = exports.compareScreenshot = exports.looksSame = void 0;
const tslib_1 = require("tslib");
const LooksSame = require("looks-same");
const path = require("path");
const fs = require("fs");
const pngjs_1 = require("pngjs");
const screenshotComparerDefault = {
    path: './testing',
    highlightColor: { r: 0xff, g: 0, b: 0xff },
    maskRadius: 5,
    attempts: 3,
    attemptTimeout: 500,
    looksSameComparisonOptions: {
        strict: false,
        tolerance: 5,
        ignoreAntialiasing: true,
        antialiasingTolerance: 5,
        ignoreCaret: true,
    },
};
function ensureArtifactsPath(artifactsPath) {
    if (!fs.existsSync(artifactsPath)) {
        fs.mkdirSync(artifactsPath, { recursive: true });
    }
}
function saveArtifacts({ artifactsPath, screenshotFileName, etalonFileName, }) {
    function copyToArtifacts(sourcePath, postfix = '') {
        const fileName = path.basename(sourcePath, '.png');
        const targetPath = path.join(artifactsPath, `${fileName}${postfix}.png`);
        if (fs.existsSync(sourcePath)) {
            fs.copyFileSync(sourcePath, targetPath);
        }
    }
    copyToArtifacts(screenshotFileName);
    copyToArtifacts(etalonFileName, '_etalon');
}
function looksSame({ etalonFileName, screenshotBuffer, comparisonOptions }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            LooksSame(etalonFileName, screenshotBuffer, comparisonOptions, (_error, result) => {
                if (_error) {
                    reject(_error);
                }
                else {
                    resolve(result.equal);
                }
            });
        });
    });
}
exports.looksSame = looksSame;
function getMaskedScreenshotBuffer({ screenshotName, screenshotFileName, etalonFileName, maskFileName, }) {
    function isSizeEqual(image1, image2) {
        return image1.height === image2.height && image1.width === image2.width;
    }
    function getImage(imagePath) {
        const imageData = fs.readFileSync(imagePath);
        return pngjs_1.PNG.sync.read(imageData, { filterType: -1 });
    }
    function applyMask(etalonImg, screenshotImg, maskImg) {
        for (let y = 0; y < screenshotImg.height; y += 1) {
            for (let x = 0; x < screenshotImg.width; x += 1) {
                const index = (screenshotImg.width * y + x) << 2;
                if (maskImg.data[index + 0] < 255
                    && maskImg.data[index + 1] < 255
                    && maskImg.data[index + 2] < 255) {
                    screenshotImg.data[index + 0] = etalonImg.data[index + 0];
                    screenshotImg.data[index + 1] = etalonImg.data[index + 1];
                    screenshotImg.data[index + 2] = etalonImg.data[index + 2];
                    screenshotImg.data[index + 3] = etalonImg.data[index + 3];
                }
            }
        }
        return pngjs_1.PNG.sync.write(screenshotImg);
    }
    if (!fs.existsSync(etalonFileName)) {
        throw new Error(`Etalon file not found: ${etalonFileName}`);
    }
    const etalonImg = getImage(etalonFileName);
    const screenshotImg = getImage(screenshotFileName);
    if (!isSizeEqual(etalonImg, screenshotImg)) {
        throw new Error(`The screenshot size (W:${screenshotImg.width}, H:${screenshotImg.height}) does not match the etalon size (W:${etalonImg.width}, H:${etalonImg.height}) for: ${screenshotName}`);
    }
    if (!fs.existsSync(maskFileName)) {
        return fs.readFileSync(screenshotFileName);
    }
    const maskImg = getImage(maskFileName);
    if (!isSizeEqual(etalonImg, maskImg)) {
        throw new Error(`Mask size does not match etalon size for screenshot: ${screenshotName}`);
    }
    const targetImageBuffer = applyMask(etalonImg, screenshotImg, maskImg);
    return targetImageBuffer;
}
function getDiff({ etalonFileName, screenshotBuffer, options, }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        function colorToString(color) {
            return `#${Object.values(color).map((n) => n.toString(16).padStart(2, '0')).join('')}`;
        }
        const highlightColor = colorToString(options.highlightColor);
        return new Promise((resolve, reject) => {
            const diffOptions = Object.assign(Object.assign({}, options.looksSameComparisonOptions), { reference: etalonFileName, current: screenshotBuffer, highlightColor });
            LooksSame.createDiff(diffOptions, (error, buffer) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(buffer);
                }
            });
        });
    });
}
function getMask(diffBuffer, maskFileName, options) {
    function transformImage(image, func) {
        for (let y = 0; y < image.height; y += 1) {
            for (let x = 0; x < image.width; x += 1) {
                const index = (image.width * y + x) << 2;
                func(image.data, index, x, y);
            }
        }
    }
    function makeTransparentExceptColor(image, { r, g, b }) {
        transformImage(image, (data, index) => {
            const isHighlighted = data[index + 0] === r
                && data[index + 1] === g
                && data[index + 2] === b;
            const color = isHighlighted ? 0 : 255;
            data[index + 0] = color;
            data[index + 1] = color;
            data[index + 2] = color;
        });
    }
    function applyMaskRadius(image, maskRadius) {
        const aroundColor = 7;
        transformImage(image, (data, index, x, y) => {
            const isHighlighted = data[index] === 0;
            if (isHighlighted) {
                const yBegin = Math.max(0, y - maskRadius);
                const xBegin = Math.max(0, x - maskRadius);
                const yEnd = Math.min(image.height, y + maskRadius);
                const xEnd = Math.min(image.width, x + maskRadius);
                for (let ry = yBegin; ry < yEnd; ry += 1) {
                    for (let rx = xBegin; rx < xEnd; rx += 1) {
                        const roundIndex = (image.width * ry + rx) << 2;
                        if (data[roundIndex] === 255) {
                            data[roundIndex] = aroundColor;
                        }
                    }
                }
            }
        });
        transformImage(image, (data, index) => {
            if (data[index] === aroundColor) {
                data[index + 0] = 0;
                data[index + 1] = 0;
                data[index + 2] = 0;
            }
        });
    }
    function applyPrevMask(image, prevMaskImage) {
        transformImage(image, (data, index) => {
            const isPrevHighlighted = prevMaskImage.data[index] === 0;
            if (isPrevHighlighted) {
                data[index + 0] = 0;
                data[index + 1] = 0;
                data[index + 2] = 0;
            }
        });
    }
    const image = pngjs_1.PNG.sync.read(diffBuffer);
    const maskBuffer = fs.existsSync(maskFileName) && fs.readFileSync(maskFileName);
    const maskImg = maskBuffer && pngjs_1.PNG.sync.read(maskBuffer);
    makeTransparentExceptColor(image, options.highlightColor);
    if (options.maskRadius) {
        applyMaskRadius(image, options.maskRadius);
    }
    if (maskImg) {
        applyPrevMask(image, maskImg);
    }
    return pngjs_1.PNG.sync.write(image);
}
function tryGetValidScreenshot({ t, screenshotName, element, screenshotFileName, etalonFileName, maskFileName, options, }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let equal = false;
        let attempt = 0;
        let screenshotBuffer = null;
        while (!equal && attempt < options.attempts) {
            attempt += 1;
            if (attempt > 1) {
                fs.unlinkSync(screenshotFileName);
            }
            yield (element
                ? t.takeElementScreenshot(element, screenshotFileName)
                : t.takeScreenshot(screenshotFileName));
            screenshotBuffer = getMaskedScreenshotBuffer({
                screenshotName, screenshotFileName, etalonFileName, maskFileName,
            });
            equal = yield looksSame({
                etalonFileName,
                screenshotBuffer,
                comparisonOptions: options.looksSameComparisonOptions,
            });
            if (!equal && attempt < options.attempts) {
                yield t.wait(options.attemptTimeout);
            }
        }
        return { equal, screenshotBuffer };
    });
}
function getComparerOptions(t, comparisonOptions) {
    const configOptions = t.testRun.opts['screenshots-comparer'];
    return Object.assign(Object.assign(Object.assign({}, screenshotComparerDefault), configOptions), comparisonOptions);
}
function compareScreenshot(t, screenshotName, element = null, comparisonOptions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = getComparerOptions(t, comparisonOptions);
        const testRoot = options.path;
        const screenshotsPath = path.join(testRoot, '/screenshots');
        const artifactsPath = path.join(testRoot, '/artifacts/compared-screenshots');
        const screenshotFileName = path.join(screenshotsPath, screenshotName.endsWith('.png') ? screenshotName : `${screenshotName}.png`);
        const etalonsPath = path.join(path.dirname(t.testRun.test.testFile.filename), 'etalons');
        const etalonFileName = path.join(etalonsPath, screenshotName);
        const maskFileName = path.join(etalonsPath, screenshotName.replace('.png', '_mask.png'));
        try {
            ensureArtifactsPath(artifactsPath);
            const { equal, screenshotBuffer } = yield tryGetValidScreenshot({
                t, screenshotName, element, screenshotFileName, etalonFileName, maskFileName, options,
            });
            if (!equal) {
                const diffFileName = path.join(artifactsPath, screenshotName.replace('.png', '_diff.png'));
                const diffMaskFileName = path.join(artifactsPath, screenshotName.replace('.png', '_mask.png'));
                const diffBuffer = yield getDiff({
                    etalonFileName, screenshotBuffer, options,
                });
                const maskBuffer = getMask(diffBuffer, maskFileName, options);
                fs.writeFileSync(diffFileName, diffBuffer);
                fs.writeFileSync(diffMaskFileName, maskBuffer);
                saveArtifacts({ artifactsPath, screenshotFileName, etalonFileName });
                return false;
            }
            return true;
        }
        catch (e) {
            saveArtifacts({ artifactsPath, screenshotFileName, etalonFileName });
            throw e;
        }
    });
}
exports.compareScreenshot = compareScreenshot;
function createScreenshotsComparer(t) {
    const errorMessages = [];
    const takeScreenshot = (screenshotName, element = null, comparisonOptions) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const isValid = yield compareScreenshot(t, screenshotName, element, comparisonOptions);
            if (!isValid) {
                errorMessages.push(`Screenshot:'${screenshotName}' invalid`);
            }
        }
        catch (e) {
            errorMessages.push(`Screenshot:'${screenshotName}' invalid, internalError: ${e.message}`);
        }
        return true;
    });
    return {
        takeScreenshot,
        compareResults: {
            isValid: () => errorMessages.length === 0,
            errorMessages: () => errorMessages.join('\r\n'),
        },
    };
}
exports.createScreenshotsComparer = createScreenshotsComparer;
//# sourceMappingURL=comparer.js.map