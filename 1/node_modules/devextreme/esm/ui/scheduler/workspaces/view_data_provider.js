/**
 * DevExtreme (esm/ui/scheduler/workspaces/view_data_provider.js)
 * Version: 21.1.2 (build 21124-0324)
 * Build date: Tue May 04 2021
 *
 * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
import dateUtils from "../../../core/utils/date";
import {
    HORIZONTAL_GROUP_ORIENTATION
} from "../constants";
class ViewDataGenerator {
    constructor(workspace) {
        this.workspace = workspace
    }
    get workspace() {
        return this._workspace
    }
    set workspace(value) {
        this._workspace = value
    }
    get isVerticalGroupedWorkspace() {
        return this.workspace._isVerticalGroupedWorkSpace()
    }
    get isStandaloneAllDayPanel() {
        return !this.isVerticalGroupedWorkspace && this.workspace.isAllDayPanelVisible
    }
    _getCompleteViewDataMap(options) {
        var {
            rowCountInGroup: rowCountInGroup,
            cellCountInGroupRow: cellCountInGroupRow,
            groupsList: groupsList,
            groupByDate: groupByDate,
            isHorizontalGrouping: isHorizontalGrouping,
            isVerticalGrouping: isVerticalGrouping,
            totalCellCount: totalCellCount,
            groupCount: groupCount
        } = options;
        var viewDataMap = [];
        var step = groupByDate ? groupCount : 1;
        var allDayPanelData = this._generateAllDayPanelData(options, cellCountInGroupRow, step);
        var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, step);
        allDayPanelData && viewDataMap.push(allDayPanelData);
        viewDataMap.push(...viewCellsData);
        if (isHorizontalGrouping && !groupByDate) {
            viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList)
        }
        if (isVerticalGrouping) {
            viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList)
        }
        if (groupByDate) {
            viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList)
        }
        var completeViewDataMap = this._addKeysToCells(viewDataMap, totalCellCount);
        return completeViewDataMap
    }
    _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {
        var result = viewDataMap.map(row => row.slice());
        groupsList.slice(1).forEach((groups, index) => {
            var groupIndex = index + 1;
            viewDataMap.forEach((row, rowIndex) => {
                var nextGroupRow = row.map(cellData => _extends({}, cellData, {
                    groups: groups,
                    groupIndex: groupIndex
                }));
                result[rowIndex].push(...nextGroupRow)
            })
        });
        return result
    }
    _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {
        var result = viewDataMap.map(row => row.slice());
        groupsList.slice(1).forEach((groups, index) => {
            var groupIndex = index + 1;
            var nextGroupMap = viewDataMap.map(cellsRow => {
                var nextRow = cellsRow.map(cellData => _extends({}, cellData, {
                    groupIndex: groupIndex,
                    groups: groups
                }));
                return nextRow
            });
            result.push(...nextGroupMap)
        });
        return result
    }
    _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {
        var correctedGroupList = groupsList.slice(1);
        var correctedGroupCount = correctedGroupList.length;
        var result = viewDataMap.map(cellsRow => {
            var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {
                var rowWithCurrentCell = [...currentRow, _extends({}, cell, {
                    isFirstGroupCell: true,
                    isLastGroupCell: 0 === correctedGroupCount
                }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {
                    groups: groups,
                    groupIndex: index + 1,
                    isFirstGroupCell: false,
                    isLastGroupCell: index === correctedGroupCount - 1
                }))];
                return rowWithCurrentCell
            }, []);
            return groupedByDateCellsRow
        });
        return result
    }
    _addKeysToCells(viewDataMap, totalColumnCount) {
        var {
            currentViewDataMap: result
        } = viewDataMap.reduce((_ref, row, rowIndex) => {
            var {
                allDayPanelsCount: allDayPanelsCount,
                currentViewDataMap: currentViewDataMap
            } = _ref;
            var isAllDay = row[0].allDay;
            var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;
            var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;
            currentViewDataMap[rowIndex].forEach((cell, cellIndex) => {
                cell.key = keyBase + cellIndex
            });
            return {
                allDayPanelsCount: currentAllDayPanelsCount,
                currentViewDataMap: currentViewDataMap
            }
        }, {
            allDayPanelsCount: 0,
            currentViewDataMap: viewDataMap
        });
        return result
    }
    _getCompleteDateHeaderMap(options, completeViewDataMap) {
        var {
            isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData
        } = options;
        var result = [];
        if (isGenerateWeekDaysHeaderData) {
            var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);
            result.push(weekDaysRow)
        }
        var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);
        result.push(dateRow);
        return result
    }
    _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {
        var {
            groupByDate: groupByDate,
            horizontalGroupCount: horizontalGroupCount,
            cellCountInDay: cellCountInDay,
            getWeekDaysHeaderText: getWeekDaysHeaderText,
            daysInView: daysInView
        } = options;
        var index = completeViewDataMap[0][0].allDay ? 1 : 0;
        var colSpan = groupByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;
        var weekDaysRow = [];
        for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {
            var cell = completeViewDataMap[index][dayIndex * cellCountInDay];
            weekDaysRow.push(_extends({}, cell, {
                colSpan: colSpan,
                text: getWeekDaysHeaderText(cell.startDate),
                isFirstGroupCell: false,
                isLastGroupCell: false
            }))
        }
        return weekDaysRow
    }
    _generateHeaderDateRow(options, completeViewDataMap) {
        var {
            getDateHeaderText: getDateHeaderText,
            today: today,
            groupByDate: groupByDate,
            horizontalGroupCount: horizontalGroupCount,
            cellCountInGroupRow: cellCountInGroupRow,
            groupOrientation: groupOrientation,
            getDateHeaderDate: getDateHeaderDate
        } = options;
        var dates = [];
        for (var dateIndex = 0; dateIndex < cellCountInGroupRow; dateIndex += 1) {
            dates.push(getDateHeaderDate(dateIndex))
        }
        var index = completeViewDataMap[0][0].allDay ? 1 : 0;
        var columnCount = completeViewDataMap[index].length;
        var dateHeaderColumnCount = groupByDate ? columnCount / horizontalGroupCount : columnCount;
        var colSpan = groupByDate ? horizontalGroupCount : 1;
        var isVerticalGrouping = "vertical" === groupOrientation;
        var slicedByColumnsData = completeViewDataMap[index].slice(0, dateHeaderColumnCount);
        return slicedByColumnsData.map((_ref2, index) => {
            var {
                startDate: startDate,
                isFirstGroupCell: isFirstGroupCell,
                isLastGroupCell: isLastGroupCell
            } = _ref2, restProps = _objectWithoutPropertiesLoose(_ref2, ["startDate", "endDate", "isFirstGroupCell", "isLastGroupCell"]);
            return _extends({}, restProps, {
                startDate: dates[index % cellCountInGroupRow],
                text: getDateHeaderText(index % cellCountInGroupRow),
                today: dateUtils.sameDate(startDate, today),
                colSpan: colSpan,
                isFirstGroupCell: groupByDate || isFirstGroupCell && !isVerticalGrouping,
                isLastGroupCell: groupByDate || isLastGroupCell && !isVerticalGrouping
            })
        })
    }
    _getCompleteTimePanelMap(options, completeViewDataMap) {
        var {
            rowCountInGroup: rowCountInGroup,
            getTimeCellDate: getTimeCellDate
        } = options;
        var times = [];
        for (var rowIndex = 0; rowIndex < rowCountInGroup; rowIndex += 1) {
            times.push(getTimeCellDate(rowIndex))
        }
        var allDayRowsCount = 0;
        return completeViewDataMap.map((row, index) => {
            var _row$ = row[0],
                {
                    allDay: allDay,
                    startDate: startDate
                } = _row$,
                restCellProps = _objectWithoutPropertiesLoose(_row$, ["allDay", "startDate", "endDate"]);
            if (allDay) {
                allDayRowsCount += 1
            }
            var timeIndex = (index - allDayRowsCount) % rowCountInGroup;
            return _extends({}, restCellProps, {
                allDay: allDay,
                startDate: allDay ? startDate : times[timeIndex]
            })
        })
    }
    _generateViewDataMap(completeViewDataMap, options) {
        var {
            rowCount: rowCount,
            startCellIndex: startCellIndex,
            cellCount: cellCount
        } = options;
        var {
            startRowIndex: startRowIndex
        } = options;
        var sliceCells = (row, rowIndex, startIndex, count) => row.slice(startIndex, startIndex + count).map((cellData, cellIndex) => ({
            cellData: cellData,
            position: {
                rowIndex: rowIndex,
                cellIndex: cellIndex
            }
        }));
        var correctedStartRowIndex = startRowIndex;
        var allDayPanelMap = [];
        if (this.isStandaloneAllDayPanel) {
            correctedStartRowIndex++;
            allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount)
        }
        var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));
        return {
            allDayPanelMap: allDayPanelMap,
            dateTableMap: dateTableMap
        }
    }
    _generateDateHeaderMap(completeDateHeaderMap, options) {
        return completeDateHeaderMap.map(headerRow => headerRow.slice(0))
    }
    _generateTimePanelData(completeTimePanelMap, options) {
        var {
            startRowIndex: startRowIndex,
            rowCount: rowCount,
            topVirtualRowHeight: topVirtualRowHeight,
            bottomVirtualRowHeight: bottomVirtualRowHeight,
            cellCountInGroupRow: cellCountInGroupRow
        } = options;
        var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();
        var showAllDayPanel = this.workspace.isAllDayPanelVisible;
        var indexDifference = this.isVerticalGroupedWorkspace || !showAllDayPanel ? 0 : 1;
        var correctedStartRowIndex = startRowIndex + indexDifference;
        var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount);
        var timePanelData = {
            topVirtualRowHeight: topVirtualRowHeight,
            bottomVirtualRowHeight: bottomVirtualRowHeight,
            isGroupedAllDayPanel: isGroupedAllDayPanel,
            cellCountInGroupRow: cellCountInGroupRow
        };
        var {
            previousGroupedData: groupedData
        } = this._generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel);
        timePanelData.groupedData = groupedData;
        return timePanelData
    }
    _generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel) {
        return timePanelMap.reduce((_ref3, cellData) => {
            var {
                previousGroupIndex: previousGroupIndex,
                previousGroupedData: previousGroupedData
            } = _ref3;
            var currentGroupIndex = cellData.groupIndex;
            if (currentGroupIndex !== previousGroupIndex) {
                previousGroupedData.push({
                    dateTable: [],
                    isGroupedAllDayPanel: isGroupedAllDayPanel,
                    groupIndex: currentGroupIndex
                })
            }
            if (cellData.allDay) {
                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData
            } else {
                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData)
            }
            return {
                previousGroupIndex: currentGroupIndex,
                previousGroupedData: previousGroupedData
            }
        }, {
            previousGroupIndex: -1,
            previousGroupedData: []
        })
    }
    _getViewDataFromMap(viewDataMap, options) {
        var {
            topVirtualRowHeight: topVirtualRowHeight,
            bottomVirtualRowHeight: bottomVirtualRowHeight,
            leftVirtualCellWidth: leftVirtualCellWidth,
            rightVirtualCellWidth: rightVirtualCellWidth,
            cellCountInGroupRow: cellCountInGroupRow,
            totalCellCount: totalCellCount,
            totalRowCount: totalRowCount,
            cellCount: cellCount,
            rowCount: rowCount,
            startRowIndex: startRowIndex,
            startCellIndex: startCellIndex
        } = options;
        var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();
        var {
            allDayPanelMap: allDayPanelMap,
            dateTableMap: dateTableMap
        } = viewDataMap;
        var {
            previousGroupedData: groupedData
        } = dateTableMap.reduce((_ref4, cellsRow) => {
            var {
                previousGroupIndex: previousGroupIndex,
                previousGroupedData: previousGroupedData
            } = _ref4;
            var cellDataRow = cellsRow.map(_ref5 => {
                var {
                    cellData: cellData
                } = _ref5;
                return cellData
            });
            var firstCell = cellDataRow[0];
            var isAllDayRow = firstCell.allDay;
            var currentGroupIndex = firstCell.groupIndex;
            if (currentGroupIndex !== previousGroupIndex) {
                previousGroupedData.push({
                    dateTable: [],
                    isGroupedAllDayPanel: isGroupedAllDayPanel,
                    groupIndex: currentGroupIndex
                })
            }
            if (isAllDayRow) {
                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow
            } else {
                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow)
            }
            return {
                previousGroupedData: previousGroupedData,
                previousGroupIndex: currentGroupIndex
            }
        }, {
            previousGroupIndex: -1,
            previousGroupedData: []
        });
        if (this.isStandaloneAllDayPanel) {
            groupedData[0].allDayPanel = allDayPanelMap.map(_ref6 => {
                var {
                    cellData: cellData
                } = _ref6;
                return cellData
            })
        }
        return {
            groupedData: groupedData,
            topVirtualRowHeight: topVirtualRowHeight,
            bottomVirtualRowHeight: bottomVirtualRowHeight,
            leftVirtualCellWidth: leftVirtualCellWidth,
            rightVirtualCellWidth: rightVirtualCellWidth,
            cellCountInGroupRow: cellCountInGroupRow,
            isGroupedAllDayPanel: isGroupedAllDayPanel,
            leftVirtualCellCount: startCellIndex,
            rightVirtualCellCount: totalCellCount - startCellIndex - cellCount,
            topVirtualRowCount: startRowIndex,
            bottomVirtualRowCount: totalRowCount - startRowIndex - rowCount
        }
    }
    _generateViewCellsData(options, rowsCount) {
        var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        var {
            cellCountInGroupRow: cellCountInGroupRow,
            cellDataGetters: cellDataGetters
        } = options;
        var viewCellsData = [];
        for (var rowIndex = 0; rowIndex < rowsCount; rowIndex += 1) {
            viewCellsData.push(this._generateCellsRow(options, cellDataGetters, rowIndex, cellCountInGroupRow, step))
        }
        return viewCellsData
    }
    _generateAllDayPanelData(options, cellCount) {
        var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        var workSpace = this.workspace;
        if (!workSpace.isAllDayPanelVisible) {
            return null
        }
        return this._generateCellsRow(options, [workSpace._getAllDayCellData.bind(workSpace)], 0, cellCount, step)
    }
    _generateCellsRow(options, cellDataGetters, rowIndex, columnCount, step) {
        var _this = this;
        var cellsRow = [];
        var _loop = function(columnIndex) {
            var correctedColumnIndex = step * columnIndex;
            var cellDataValue = cellDataGetters.reduce((data, getter) => _extends({}, data, getter(void 0, rowIndex, correctedColumnIndex, 0, data.startDate).value), {});
            cellDataValue.index = rowIndex * columnCount + columnIndex;
            cellDataValue.isFirstGroupCell = _this._isFirstGroupCell(rowIndex, columnIndex, options);
            cellDataValue.isLastGroupCell = _this._isLastGroupCell(rowIndex, columnIndex, options);
            cellsRow.push(cellDataValue)
        };
        for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {
            _loop(columnIndex)
        }
        return cellsRow
    }
    _calculateCellIndex(horizontalGroupCount, groupOrientation, isGroupedByDate, rowIndex, columnIndex, columnsNumber) {
        var groupCount = horizontalGroupCount || 1;
        var index = rowIndex * columnsNumber + columnIndex;
        var columnsInGroup = columnsNumber / groupCount;
        if ("horizontal" === groupOrientation) {
            var columnIndexInCurrentGroup = columnIndex % columnsInGroup;
            if (isGroupedByDate) {
                columnIndexInCurrentGroup = Math.floor(columnIndex / groupCount)
            }
            index = rowIndex * columnsInGroup + columnIndexInCurrentGroup
        }
        return index
    }
    generateGroupedDataMap(viewDataMap) {
        var {
            allDayPanelMap: allDayPanelMap,
            dateTableMap: dateTableMap
        } = viewDataMap;
        var {
            previousGroupedDataMap: dateTableGroupedMap
        } = dateTableMap.reduce((previousOptions, cellsRow) => {
            var {
                previousGroupedDataMap: previousGroupedDataMap,
                previousRowIndex: previousRowIndex,
                previousGroupIndex: previousGroupIndex
            } = previousOptions;
            var {
                groupIndex: currentGroupIndex
            } = cellsRow[0].cellData;
            var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;
            cellsRow.forEach(cell => {
                var {
                    groupIndex: groupIndex
                } = cell.cellData;
                if (!previousGroupedDataMap[groupIndex]) {
                    previousGroupedDataMap[groupIndex] = []
                }
                if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {
                    previousGroupedDataMap[groupIndex][currentRowIndex] = []
                }
                previousGroupedDataMap[groupIndex][currentRowIndex].push(cell)
            });
            return {
                previousGroupedDataMap: previousGroupedDataMap,
                previousRowIndex: currentRowIndex,
                previousGroupIndex: currentGroupIndex
            }
        }, {
            previousGroupedDataMap: [],
            previousRowIndex: -1,
            previousGroupIndex: -1
        });
        var allDayPanelGroupedMap = [];
        null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {
            var {
                groupIndex: groupIndex
            } = cell.cellData;
            if (!allDayPanelGroupedMap[groupIndex]) {
                allDayPanelGroupedMap[groupIndex] = []
            }
            allDayPanelGroupedMap[groupIndex].push(cell)
        });
        return {
            allDayPanelGroupedMap: allDayPanelGroupedMap,
            dateTableGroupedMap: dateTableGroupedMap
        }
    }
    _isFirstGroupCell(rowIndex, columnIndex, options) {
        var {
            groupOrientation: groupOrientation,
            rowCountInGroup: rowCountInGroup,
            cellCountInGroupRow: cellCountInGroupRow,
            groupCount: groupCount
        } = options;
        if (this.workspace.isGroupedByDate()) {
            return columnIndex % groupCount === 0
        }
        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
            return columnIndex % cellCountInGroupRow === 0
        }
        return rowIndex % rowCountInGroup === 0
    }
    _isLastGroupCell(rowIndex, columnIndex, options) {
        var {
            groupOrientation: groupOrientation,
            rowCountInGroup: rowCountInGroup,
            cellCountInGroupRow: cellCountInGroupRow,
            groupCount: groupCount
        } = options;
        if (this.workspace.isGroupedByDate()) {
            return (columnIndex + 1) % groupCount === 0
        }
        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {
            return (columnIndex + 1) % cellCountInGroupRow === 0
        }
        return (rowIndex + 1) % rowCountInGroup === 0
    }
}
class GroupedDataMapProvider {
    constructor(viewDataGenerator, viewDataMap, completeViewDataMap, workspace) {
        this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);
        this.completeViewDataMap = completeViewDataMap;
        this._workspace = workspace
    }
    getGroupStartDate(groupIndex) {
        var firstRow = this.getFirstGroupRow(groupIndex);
        if (firstRow) {
            var {
                startDate: startDate
            } = firstRow[0].cellData;
            return startDate
        }
    }
    getGroupEndDate(groupIndex) {
        var lastRow = this.getLastGroupRow(groupIndex);
        if (lastRow) {
            var lastCellIndex = lastRow.length - 1;
            var {
                cellData: cellData
            } = lastRow[lastCellIndex];
            var {
                endDate: endDate
            } = cellData;
            return endDate
        }
    }
    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {
        if (isAllDay) {
            return this.findAllDayGroupCellStartDate(groupIndex, startDate)
        }
        var groupData = this.getGroupFromDateTableGroupMap(groupIndex);
        var checkCellStartDate = (rowIndex, cellIndex) => {
            var {
                cellData: cellData
            } = groupData[rowIndex][cellIndex];
            var {
                startDate: secondMin,
                endDate: secondMax
            } = cellData;
            if (dateUtils.intervalsOverlap({
                    firstMin: startDate,
                    firstMax: endDate,
                    secondMin: secondMin,
                    secondMax: secondMax
                })) {
                return secondMin
            }
        };
        var startDateVerticalSearch = (() => {
            var cellCount = groupData[0].length;
            for (var cellIndex = 0; cellIndex < cellCount; ++cellIndex) {
                for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
                    var result = checkCellStartDate(rowIndex, cellIndex);
                    if (result) {
                        return result
                    }
                }
            }
        })();
        var startDateHorizontalSearch = (() => {
            for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {
                var row = groupData[rowIndex];
                for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {
                    var result = checkCellStartDate(rowIndex, cellIndex);
                    if (result) {
                        return result
                    }
                }
            }
        })();
        return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch
    }
    findAllDayGroupCellStartDate(groupIndex, startDate) {
        var groupStartDate = this.getGroupStartDate(groupIndex);
        return groupStartDate > startDate ? groupStartDate : startDate
    }
    findCellPositionInMap(cellInfo) {
        var {
            groupIndex: groupIndex,
            startDate: startDate,
            isAllDay: isAllDay,
            index: index
        } = cellInfo;
        var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();
        var isStartDateInCell = cellData => {
            if (!this._workspace.isDateAndTimeView) {
                return dateUtils.sameDate(startDate, cellData.startDate)
            }
            var cellStartTime = cellData.startDate.getTime();
            var cellEndTime = cellData.endDate.getTime();
            return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime
        };
        var {
            allDayPanelGroupedMap: allDayPanelGroupedMap,
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        var rows = isAllDay && !this._workspace._isVerticalGroupedWorkSpace() ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];
        for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {
            var row = rows[rowIndex];
            for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {
                var cell = row[cellIndex];
                var {
                    cellData: cellData
                } = cell;
                if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {
                    if (isStartDateInCell(cellData)) {
                        return cell.position
                    }
                }
            }
        }
        return
    }
    _isSameGroupIndexAndIndex(cellData, groupIndex, index) {
        return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index)
    }
    getCellsGroup(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        var groupData = dateTableGroupedMap[groupIndex];
        if (groupData) {
            var {
                cellData: cellData
            } = groupData[0][0];
            return cellData.groups
        }
    }
    getCompletedGroupsInfo() {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        return dateTableGroupedMap.map(groupData => {
            var firstCell = groupData[0][0];
            var {
                allDay: allDay,
                groupIndex: groupIndex
            } = firstCell.cellData;
            return {
                allDay: allDay,
                groupIndex: groupIndex,
                startDate: this.getGroupStartDate(groupIndex),
                endDate: this.getGroupEndDate(groupIndex)
            }
        }).filter(_ref7 => {
            var {
                startDate: startDate
            } = _ref7;
            return !!startDate
        })
    }
    getGroupIndices() {
        return this.getCompletedGroupsInfo().map(_ref8 => {
            var {
                groupIndex: groupIndex
            } = _ref8;
            return groupIndex
        })
    }
    getGroupFromDateTableGroupMap(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        return dateTableGroupedMap[groupIndex]
    }
    getFirstGroupRow(groupIndex) {
        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);
        if (groupedData) {
            var {
                cellData: cellData
            } = groupedData[0][0];
            return !cellData.allDay ? groupedData[0] : groupedData[1]
        }
    }
    getLastGroupRow(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        var groupedData = dateTableGroupedMap[groupIndex];
        if (groupedData) {
            var lastRowIndex = groupedData.length - 1;
            return groupedData[lastRowIndex]
        }
    }
    getLasGroupCellPosition(groupIndex) {
        var groupRow = this.getLastGroupRow(groupIndex);
        return groupRow[groupRow.length - 1].position
    }
    getRowCountInGroup(groupIndex) {
        var groupRow = this.getLastGroupRow(groupIndex);
        var cellAmount = groupRow.length;
        var lastCellData = groupRow[cellAmount - 1].cellData;
        var lastCellIndex = lastCellData.index;
        return (lastCellIndex + 1) / groupRow.length
    }
}
export default class ViewDataProvider {
    constructor(workspace) {
        this._viewDataGenerator = null;
        this._viewData = [];
        this._completeViewDataMap = [];
        this._completeDateHeaderMap = [];
        this._viewDataMap = [];
        this._groupedDataMapProvider = null;
        this._workspace = workspace
    }
    get viewDataGenerator() {
        if (!this._viewDataGenerator) {
            this._viewDataGenerator = new ViewDataGenerator(this._workspace)
        }
        return this._viewDataGenerator
    }
    get completeViewDataMap() {
        return this._completeViewDataMap
    }
    set completeViewDataMap(value) {
        this._completeViewDataMap = value
    }
    get completeDateHeaderMap() {
        return this._completeDateHeaderMap
    }
    set completeDateHeaderMap(value) {
        this._completeDateHeaderMap = value
    }
    get completeTimePanelMap() {
        return this._completeTimePanelMap
    }
    set completeTimePanelMap(value) {
        this._completeTimePanelMap = value
    }
    get viewData() {
        return this._viewData
    }
    set viewData(value) {
        this._viewData = value
    }
    get viewDataMap() {
        return this._viewDataMap
    }
    set viewDataMap(value) {
        this._viewDataMap = value
    }
    get dateHeaderMap() {
        return this._dateHeaderMap
    }
    set dateHeaderMap(value) {
        this._dateHeaderMap = value
    }
    get timePanelData() {
        return this._timePanelData
    }
    set timePanelData(value) {
        this._timePanelData = value
    }
    get groupedDataMap() {
        return this._groupedDataMapProvider.groupedDataMap
    }
    get isVerticalGroupedWorkspace() {
        return this._workspace._isVerticalGroupedWorkSpace()
    }
    update(isGenerateNewViewData) {
        var {
            viewDataGenerator: viewDataGenerator,
            _workspace: _workspace
        } = this;
        var renderOptions = _workspace.generateRenderOptions();
        if (isGenerateNewViewData) {
            this.completeViewDataMap = viewDataGenerator._getCompleteViewDataMap(renderOptions);
            this.completeDateHeaderMap = viewDataGenerator._getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);
            this.completeTimePanelMap = viewDataGenerator._getCompleteTimePanelMap(renderOptions, this.completeViewDataMap)
        }
        this.viewDataMap = viewDataGenerator._generateViewDataMap(this.completeViewDataMap, renderOptions);
        this.viewData = viewDataGenerator._getViewDataFromMap(this.viewDataMap, renderOptions);
        this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, this._workspace);
        this.dateHeaderMap = viewDataGenerator._generateDateHeaderMap(this.completeDateHeaderMap, renderOptions);
        this.timePanelData = viewDataGenerator._generateTimePanelData(this.completeTimePanelMap, renderOptions)
    }
    getStartDate() {
        var {
            groupedData: groupedData
        } = this.viewData;
        var {
            dateTable: dateTable
        } = groupedData[0];
        return dateTable[0][0].startDate
    }
    getGroupStartDate(groupIndex) {
        return this._groupedDataMapProvider.getGroupStartDate(groupIndex)
    }
    getGroupEndDate(groupIndex) {
        return this._groupedDataMapProvider.getGroupEndDate(groupIndex)
    }
    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {
        return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay)
    }
    findAllDayGroupCellStartDate(groupIndex, startDate) {
        return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate)
    }
    findCellPositionInMap(cellInfo) {
        return this._groupedDataMapProvider.findCellPositionInMap(cellInfo)
    }
    getCellsGroup(groupIndex) {
        return this._groupedDataMapProvider.getCellsGroup(groupIndex)
    }
    getCompletedGroupsInfo() {
        return this._groupedDataMapProvider.getCompletedGroupsInfo()
    }
    getGroupIndices() {
        return this._groupedDataMapProvider.getGroupIndices()
    }
    getLasGroupCellPosition(groupIndex) {
        return this._groupedDataMapProvider.getLasGroupCellPosition(groupIndex)
    }
    getRowCountInGroup(groupIndex) {
        return this._groupedDataMapProvider.getRowCountInGroup(groupIndex)
    }
    getGroupCellCountDelta(groupIndex) {
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this._groupedDataMapProvider.groupedDataMap;
        var groupedData = dateTableGroupedMap[groupIndex];
        var {
            cellCountInGroupRow: totalCellCountInGroupRow
        } = this.viewData;
        var cellCountInGroupRow = groupedData[0].length;
        return totalCellCountInGroupRow - cellCountInGroupRow
    }
    getCellData(rowIndex, cellIndex, isAllDay) {
        if (isAllDay && !this.isVerticalGroupedWorkspace) {
            return this._viewData.groupedData[0].allDayPanel[cellIndex]
        }
        var {
            dateTableMap: dateTableMap
        } = this.viewDataMap;
        var {
            cellData: cellData
        } = dateTableMap[rowIndex][cellIndex];
        return cellData
    }
    getCellsByGroupIndexAndAllDay(groupIndex, allDay) {
        var workspace = this._workspace;
        var rowsPerGroup = workspace._getRowCountWithAllDayRows();
        var isShowAllDayPanel = workspace.isAllDayPanelVisible;
        var firstRowInGroup = this.isVerticalGroupedWorkspace ? groupIndex * rowsPerGroup : 0;
        var lastRowInGroup = this.isVerticalGroupedWorkspace ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;
        var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;
        var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;
        return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(row => row.filter(_ref9 => {
            var {
                groupIndex: currentGroupIndex
            } = _ref9;
            return groupIndex === currentGroupIndex
        }))
    }
    getGroupData(groupIndex) {
        var {
            groupedData: groupedData
        } = this.viewData;
        if (this.isVerticalGroupedWorkspace) {
            return groupedData.filter(item => item.groupIndex === groupIndex)[0]
        }
        var filterCells = row => null === row || void 0 === row ? void 0 : row.filter(cell => cell.groupIndex === groupIndex);
        var {
            allDayPanel: allDayPanel,
            dateTable: dateTable
        } = groupedData[0];
        var filteredDateTable = [];
        dateTable.forEach(row => {
            filteredDateTable.push(filterCells(row))
        });
        return {
            allDayPanel: filterCells(allDayPanel),
            dateTable: filteredDateTable
        }
    }
    getCellCountWithGroup(groupIndex) {
        var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var {
            dateTableGroupedMap: dateTableGroupedMap
        } = this.groupedDataMap;
        return dateTableGroupedMap.filter((_, index) => index <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0)
    }
    getAllDayPanel(groupIndex) {
        var groupData = this.getGroupData(groupIndex);
        return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel
    }
    isGroupIntersectDateInterval(groupIndex, startDate, endDate) {
        var groupStartDate = this.getGroupStartDate(groupIndex);
        var groupEndDate = this.getGroupEndDate(groupIndex);
        return startDate < groupEndDate && endDate > groupStartDate
    }
    findGlobalCellPosition(date) {
        var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
        var {
            completeViewDataMap: completeViewDataMap,
            _workspace: workspace
        } = this;
        var showAllDayPanel = workspace.isAllDayPanelVisible;
        for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {
            var currentRow = completeViewDataMap[rowIndex];
            for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {
                var cellData = currentRow[columnIndex];
                var {
                    startDate: currentStartDate,
                    endDate: currentEndDate,
                    groupIndex: currentGroupIndex,
                    allDay: currentAllDay
                } = cellData;
                if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {
                    return {
                        position: {
                            columnIndex: columnIndex,
                            rowIndex: showAllDayPanel && !this.isVerticalGroupedWorkspace ? rowIndex - 1 : rowIndex
                        },
                        cellData: cellData
                    }
                }
            }
        }
    }
    _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {
        var time = date.getTime();
        var trimmedTime = dateUtils.trimTime(date).getTime();
        var cellStartTime = cellStartDate.getTime();
        var cellEndTime = cellEndDate.getTime();
        return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime
    }
}
